<html>
    <head>
        <title>TEST</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script type="text/javascript" src="stats.js"></script>
        <script type="text/javascript" src="input.js"></script>
        <script type="text/javascript" src="requestAnimationFrameShim.js"></script>
        <script type="text/javascript" src="eventbus.js"></script>
        <script type="text/javascript" src="loader.js"></script>
        <script type="text/javascript" src="menus.js"></script>
        <script type="text/javascript" src="game.js"></script>
        <script type="text/javascript">

            // EDITOR -> general output to zig data structures as arrays
            // Going into editor mode means I can still play the game but I can pause it too
            // Create worlds (aka: maps)
            // -- layers
            // -- collisions
            // -- starting locations
            // -- trigger locations
            // Edit images (specifically the rgba bytes <--> zig)
            // Data
            // entities
            // scripts
            // world items
            // strings
            // timeline (seek/fast forward/rewind)

            const SIZE = 32;
            const SCALE = 2;
            let DOM = {
                width: 0,
                height: 0,
                generateGridFragment: function (color)
                {
                    let fragment = new DocumentFragment();
                    for (let i = 0; i < this.height; ++i)
                    {
                        // let row = document.createElement('div');
                        // row.classList.add('row');
                        for (let c = 0; c < this.width; ++c)
                        {
                            let div = document.createElement('div');
                            div.style.width = (SIZE) + 'px';
                            div.style.height = (SIZE) + 'px';
                            div.style.border = '1px solid ' + (color ?? 'pink');
                            div.setAttribute('data-column', i);
                            div.setAttribute('data-row', c);
                            div.classList.add('coord');
                            fragment.append(div);
                            // row.append(div);
                        }
                        // fragment.append(row);
                    }

                    return fragment;
                },
                generateGrid: function () {},
                renderWorld: function (start_x = 0, start_y = 0, end_x = null, end_y = null) {
                    // TODO: Consider what part of the world is actually supposed to get rendered
                    // TODO: Also, can we move this to webassembly ?
                    let world = GAME.getCurrentWorldSize();
                    let element_world = document.getElementById('world');
                    for (let x = start_x; x < ((end_x !== null) ? end_x : world.width); ++x)
                    {
                        for (let y = start_y; y < ((end_y !== null) ? end_y : world.height); ++y)
                        {
                            let data = GAME.getCurrentWorldData(1, x, y);
                            if (data === 0)
                            {
                                continue;
                            }
                            // BLOCKED SPACE
                            let element_item = document.querySelector('div[data-x="' + x + '"][data-y="' + y + '"]');
                            if (!element_item)
                            {
                                element_item = document.createElement('div');
                                element_item.setAttribute('data-x', x);
                                element_item.setAttribute('data-y', y);
                                element_item.classList.add('thing');
                                element_world.append(element_item);
                            }
                            var _x = x - GAME.camera_offset.x;
                            element_item.style.left = (_x * (SIZE * SCALE)) + 'px';
                            element_item.style.top = (y * (SIZE * SCALE)) + 'px';
                            element_item.classList.add('blue');
                        }
                        for (let y = start_y; y < ((end_y !== null) ? end_y : world.height); ++y)
                        {
                            let data = GAME.getCurrentWorldData(2, x, y);
                            // TODO: This is hacky. Find a better way to tell who is in this position or move it to WASM.
                            for (let e = 0; e < 2; ++e)
                            {
                                // let entity = GAME.getEntityPosition(e);
                                let entity = GAME.getEntity(e);
                                //if (entity[0] === x && entity[1] === y)
                                if (entity.x === x && entity.y === y)
                                {
                                    let element_entity = document.querySelector('div[data-entity="' + e + '"]');
                                    if (!element_entity)
                                    {
                                        element_entity = document.createElement('div');
                                        element_entity.setAttribute('data-entity', e.toString());
                                        element_entity.classList.add('thing');
                                        element_world.append(element_entity);
                                        if (e === 0)
                                        {
                                            element_entity.classList.add('purple');
                                        }
                                        else
                                        {
                                            element_entity.classList.add('red');
                                        }
                                    }
                                    var _x = x - GAME.camera_offset.x;
                                    element_entity.style.left = (_x * (SIZE * SCALE)) + 'px';
                                    element_entity.style.top = (y * (SIZE * SCALE)) + 'px';
                                    element_entity.innerHTML = entity.health;
                                }
                            }
                        }
                    }
                },
                initGame: function ()
                {
                    // TODO: Hide game or do not show it until you're done all this stuff first. Loading bar?
                    this.sizeView();

                    let world = GAME.getCurrentWorldSize();
                    // world element
                    // camera offset should always be x/y offset number even in script

                    let element_world = document.getElementById('world');
                    if (world.width < DOM.width && world.height < DOM.height)
                    {
                        // need to center it
                        let leftover_x = DOM.width - world.width;
                        leftover_x = Math.floor(leftover_x / 2);
                        let leftover_y = DOM.height - world.height;
                        leftover_y = Math.floor(leftover_y / 2);

                        element_world.style.width = (world.width * (SIZE * SCALE)) + 'px';
                        element_world.style.height = (world.height * (SIZE * SCALE)) + 'px';

                        element_world.style.left = (leftover_x * (SIZE * SCALE)) + 'px';
                        element_world.style.top = (leftover_y * (SIZE * SCALE)) + 'px';
                    }
                    else
                    {
                        if (world.width < DOM.width)
                        {
                            // TODO: THIS
                        }
                        else if (world.height < DOM.height)
                        {
                            console.log('world.height < DOM.height');
                            // TODO: THIS
                            // need to center it
                            let leftover_x = DOM.width - world.width;
                            leftover_x = Math.floor(leftover_x / 2);
                            let leftover_y = DOM.height - world.height;
                            leftover_y = Math.floor(leftover_y / 2);

                            element_world.style.width = (world.width * (SIZE * SCALE)) + 'px';
                            element_world.style.height = (world.height * (SIZE * SCALE)) + 'px';

                            //element_world.style.left = (leftover_x * (SIZE * SCALE)) + 'px';
                            element_world.style.top = (leftover_y * (SIZE * SCALE)) + 'px';
                        }
                        else
                        {
                            // TODO: THIS
                            // make element_world full width/height
                            // on renderWorld, you have to update so that you take into account GAME.camera_offset.x/y
                            // iterate world coords +/- offset and +/- view boundary and then update
                        }
                    }

                    this.renderWorld();
                },
                sizeView: function ()
                {
                    // Full height, including the scroll part
                    const full_height = Math.max(
                        // document.body.scrollHeight,
                        // document.documentElement.scrollHeight,
                        // document.body.offsetHeight,
                        // document.documentElement.offsetHeight,
                        document.body.clientHeight,
                        // document.documentElement.clientHeight
                    );
                    // Full width, including the scroll part
                    const full_width = Math.max(
                        // document.body.scrollWidth,
                        // document.documentElement.scrollWidth,
                        // document.body.offsetWidth,
                        // document.documentElement.offsetWidth,
                        document.body.clientWidth,
                        // document.documentElement.clientWidth
                    );

                    const root = document.documentElement;
                    root.style.setProperty('--scale', SCALE);

                    console.log({full_width, full_height});

                    let x = Math.floor(full_width / (SIZE * SCALE));
                    let y = Math.floor(full_height / (SIZE * SCALE));
                    // So we add a bit more space in the view
                    if (x > 6)
                    {
                        --x;
                    }
                    if (y > 6)
                    {
                        --y;
                    }
                    let x_padding = (full_width - (x * (SIZE * SCALE))) / 2;
                    let y_padding = (full_height - (y * (SIZE * SCALE))) / 2;
                    document.getElementById('view').style.margin = y_padding + 'px ' + x_padding + 'px';
                    document.getElementById('view').style.width = (x * (SIZE * SCALE)) + 'px';
                    document.getElementById('view').style.height = (y * (SIZE * SCALE)) + 'px';
                    DOM.width = x;
                    DOM.height = y;
                }
            };

            const resizeObserver = new ResizeObserver((entries) => {
                const entry = entries[0];
                // entry.contentRect
                // REDO sizing and grid
                console.log('resize called');
                //DOM.sizeView();
                // TODO: Clean this up later. initGame not a good function for this
                if (GAME) {
                    DOM.initGame();
                }
            });

            let then = performance.now();
            const interval = 1000 / 30;
            let delta = 0;
            function animateEntities () {
                let now = performance.now();
                if (now - then >= interval - delta) {
                    delta = Math.min(interval, delta + now - then - interval);
                    then = now;

                    if (_testScript[_testScript_i]) {
                        _testScript[_testScript_i]();
                    }
                    DOM.renderWorld();
                    if (GAME.getDiffListLen() > 0) {
                        let diff_list = GAME.getDiffList();
                        console.log('diff_list', diff_list);
                        // for (let i = 0; i < diff_list.length; ++i) {
                        //     let position = GAME.getEntityPosition(diff_list[i]);
                        // }
                        GAME.clearDiffList();
                    }
                }
            };
            function animate() {
                // call this function again asap
                requestAnimationFrame(animate);
                // measure time and add or remove sprites
                STATS.checkFPS();
                
                // deal with the level
                animateEntities();
            }

            LOADER.events.addEventListener('loaded', function (a) {
                // console.log(a);
                // run each frame
                GAME.initGame();
                DOM.initGame();
                animate();
            });
            window.addEventListener('load', function () {
                var element_view = document.getElementById('view');
                resizeObserver.observe(document.body);
                LOADER.loaded('window_ready');
            });
        </script>
        <style type="text/css">
            :root {
                --scale: 1;
                --size: 32;
                --scaled-size: calc(var(--size) * var(--scale));
                --scaled-size-px: calc(var(--scaled-size) * 1px);
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0px;
                padding: 0px;
                overflow: hidden;

                background-color: black;
            }
            #view {
                width: 100%;
                height: 100vh;
                /*display: flex;
                align-items: center;
                justify-content: center;*/
                background-image: 
                    linear-gradient(rgba(0, 255, 0, .7) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0, 255, 0, .7) 1px, transparent 1px);
                background-size: var(--scaled-size-px) var(--scaled-size-px);
                background-position: -1px -1px;
                border: 1px solid red;

                position: relative;
            }
            #world {
                border: 1px solid white;
                position: absolute;
            }
            .thing {
                transform: scale3d(1, 1, 1);
                position: absolute;
                width: var(--scaled-size-px);
                height: var(--scaled-size-px);
                color: white;
                font-weight: bold;
            }
            #grid {
                display: grid;
                margin: 0px auto;
                align-self: center;
                justify-self: center;
            }
            .purple { background: url('data:image/webp;base64,UklGRjADAABXRUJQVlA4TCQDAAAvf8AXAGdgJJKUl1/jI5AeeUEIgEUSxUgAJFRmcIWdbiEaNdrcYiQAEq7ABDZyg31Go8b5j/ktFKFTkLc3vs2kMngigN5DCSTVtl03kiiIgig8CqIgCnfcM1EwhUfBDHo9CkGl91NZ9jyi/xDctpEkKT0zm8VWjfos7xfkvkXEjWOWz3m4cVaFRb7owRyYyN88sOX1CjLB+973AGHT6zha8cmQLQ/PptdxEgdm3vcYhE2v8zw3lbJ34b0CCU5Q5oHIQ/spd+75GqL5mK2HUw08DMYr93wBLHfsw87DoAaQ2zhc03rlnufR4fkDwPVao0BYadN65Z4vgDl5EKiH5/f7DQKbvk02XrnneZJbwSuBVdUhpl+N8co9jxN87X871p8sA4CF7d2fhNdL6nGOUIf1VNmDpapgFkdbLC9OPfk0+UqxfgLgaA32S00fNNnT5QXEOQCr9HkF5VKYQzZzxHk2c8EgoC3YNPoy7OWK02wvE5YCSdhaZh7mwdxhKcqtCtQMuznjPFs5YZiDZRBPadfczBmP8lzuCFgeAeWaAJDnjPNsXQiDFnVx+YmolWIeKZ2QXniHyXNAyLW2BnMIK2or+P0sce44wwO5YxACOKBAa5HmjhewkRsiCswhbAULnepe5J7nkWQNMv21KGtLaVNWk+eO8+Q5IGYQlIrmtkXu+Tx/zR2mLwYKaARDaZ2Qespp8hygFAVYrVuzL3Jt6YQsd5wnzwGmxzB6HhFCH6YWOhOC3HGeIAeEPcRCgHiFjjGIaEGrRvD0eAFxDnCWFYu+qvberQLBHC/dTCHIHefJcoD5XwEVtsjkRmfgflB6RZA7zpMsA/56qURESlpjVNh3t+wcJS+AVz8qkWkIaZEpC8LccR63/KCGppWiqrWUQhRaXRfC3HGQZAioh4Xer+tqSLuGdrVLX1HuOI+fCmGtDTqUkHbdjsOcQe54AVs5wPwGQKetDmXO6XLHazACc6uoa9dpzqAr2oW54wWEOUByelmdm+mfkygzyx3PMbf5Y47oRTvuRXy3kTPOk+eI73nkOeJrHnlu+J5Hnhs+4/GH3PFBDwE=');
                background-size: contain;
                background-repeat: no-repeat;
            }
            .red { background-color:red; }
            .blue { background-color: blue; }
        </style>
    </head>
    <body>
        <div id="stats" style="position: absolute; background-color: white; padding: 6px; z-index: 2; top: 0px;">&nbsp;</div>
        <div id="view">
            <style type="text/css">
                .menu.date {
                    width: 100%;
                    height: calc(var(--scaled-size-px) * 2);
                    position: absolute;
                    top: 0;
                    left: 0;
                    text-align: right;
                    font-size: 2em;
                    color: white;
                    text-shadow: 0 0 2px black, 0 0 2px black, 0 0 2px black;
                    font-family: monospace;
                }
            </style>
            <div class="menu date">
                <div class="year">1527</div>
                <div class="month_and_day"><span class="month">May</span> <span class="day">22</span></div>
            </div>
            <style type="text/css">
                .menu.fullscreen {
                    background-color: rgb(82 159 82 / 90%);
                    width: 100%;
                    height: 100%;
                    position: absolute;
                    z-index: 2;
                    bottom: 0;
                    left: 0;
                    display: none;
                    text-align: center;
                    font-weight: bold;
                    font-size: 2em;
                    color: white;
                }
            </style>
            <div class="menu fullscreen">
                FULL SCREEN
            </div>
            <div id="world"></div>
        </div>
    </body>
</html>
