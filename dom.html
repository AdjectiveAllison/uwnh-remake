<html>
    <head>
        <title>TEST</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <script type="text/javascript" src="stats.js"></script>
        <script type="text/javascript" src="input.js"></script>
        <script type="text/javascript" src="requestAnimationFrameShim.js"></script>
        <script type="text/javascript" src="eventbus.js"></script>
        <script type="text/javascript" src="loader.js"></script>
        <script type="text/javascript" src="menus.js"></script>
        <script type="text/javascript" src="game.js"></script>
        <script type="text/javascript" src="editor.js"></script>
        <script type="text/javascript">

            // EDITOR -> general output to zig data structures as arrays
            // Going into editor mode means I can still play the game but I can pause it too
            // Create worlds (aka: maps)
            // -- layers
            // -- collisions
            // -- starting locations
            // -- trigger locations
            // Edit images (specifically the rgba bytes <--> zig)
            // Data
            // entities
            // scripts
            // world items
            // strings
            // timeline (seek/fast forward/rewind)

            // TODO: Use the 4x20 world
            // scroll camera to the very top or very bottom
            // bring main player to very top or bottom (whichever you chose)
            // now scroll camera back towards the center
            // main player stays rendered "stickied" to the edge

            const SIZE = 32;
            const SCALE = 2;
            let DOM = {
                width: 0,
                height: 0,
                generateGridFragment: function (color)
                {
                    let fragment = new DocumentFragment();
                    for (let i = 0; i < this.height; ++i)
                    {
                        // let row = document.createElement('div');
                        // row.classList.add('row');
                        for (let c = 0; c < this.width; ++c)
                        {
                            let div = document.createElement('div');
                            div.style.width = (SIZE) + 'px';
                            div.style.height = (SIZE) + 'px';
                            div.style.border = '1px solid ' + (color ?? 'pink');
                            div.setAttribute('data-column', i);
                            div.setAttribute('data-row', c);
                            div.classList.add('coord');
                            fragment.append(div);
                            // row.append(div);
                        }
                        // fragment.append(row);
                    }

                    return fragment;
                },
                generateGrid: function () {},
                renderWorld: function (start_x = 0, start_y = 0, end_x = null, end_y = null) {
                    let element_view = document.getElementById('view');
                    let world = GAME.getCurrentWorldSize();
                    if (EDITOR.camera_has_changed) {
                        var collision_blocks = document.querySelectorAll('.blue');
                        for (var c = 0; c < collision_blocks.length; ++c) {
                            collision_blocks[c].remove();
                        }
                    }
                    var renderer = {row: 0, column: 0};
                    for (var d = 0; d < GAME.getViewportData().length; ++d) {
                        if (GAME.editor_mode) {
                            var editor_block = document.querySelector('div.editor_block[data-x="' + renderer.column + '"][data-y="' + renderer.
                                row + '"]');
                            var data_element = null;
                            var coord_element = null;
                            if (!editor_block) {
                                editor_block = document.createElement('div');
                                editor_block.classList.add('editor_block');
                                editor_block.setAttribute('data-x', renderer.column);
                                editor_block.setAttribute('data-y', renderer.row);

                                var data_element = document.createElement('div');
                                data_element.classList.add('data');
                                editor_block.appendChild(data_element);

                                var coord_element = document.createElement('div');
                                coord_element.classList.add('coordinate');
                                editor_block.appendChild(coord_element);

                                element_view.append(editor_block);
                            }
                            data_element = editor_block.querySelector('.data');
                            coord_element = editor_block.querySelector('.coordinate');
                            coord_element.innerHTML = '(' + renderer.column + ', ' + renderer.row + ')';
                            data_element.innerHTML = GAME.getViewportData()[d];
                            if (GAME.getViewportData()[d] > 0) {
                                data_element.classList.add('has_value');
                            }
                            editor_block.style.left = (renderer.column * (SIZE * SCALE)) + 'px';
                            editor_block.style.top = (renderer.row * (SIZE * SCALE)) + 'px';
                        }
                        if (GAME.getViewportData()[d] > 0) {
                            // Collisions
                            if (!GAME.editor_mode) {
                                var x = renderer.column;
                                var y = renderer.row;
                                let element_item = document.querySelector('div.blue[data-x="' + x + '"][data-y="' + y + '"]');
                                if (element_item) { element_item.remove(); }
                            }
                            if (GAME.editor_mode && EDITOR.camera_has_changed) {
                                var _artificial_layer = (GAME.getCurrentWorldSize().width * GAME.getCurrentWorldSize().height) * 1;
                                var _artificial_index = GAME.getViewportData()[d];
                                var index = _artificial_index + _artificial_layer - 1;
                                var data = GAME.getWorld()[index];
                                if (data === 1) {
                                    var x = renderer.column;
                                    var y = renderer.row;
                                    let element_item = document.querySelector('div.blue[data-x="' + x + '"][data-y="' + y + '"]');
                                    if (!element_item)
                                    {
                                        element_item = document.createElement('div');
                                        element_item.classList.add('thing');
                                        element_view.append(element_item);
                                    }
                                    element_item.setAttribute('data-x', x);
                                    element_item.setAttribute('data-y', y);
                                    element_item.style.left = (x * (SIZE * SCALE)) + 'px';
                                    element_item.style.top = (y * (SIZE * SCALE)) + 'px';
                                    element_item.classList.add('blue');
                                }
                            }

                            // Entities
                            var _artificial_layer = (GAME.getCurrentWorldSize().width * GAME.getCurrentWorldSize().height) * 2;
                            var _artificial_index = GAME.getViewportData()[d];
                            var index = _artificial_index + _artificial_layer - 1;
                            var data = GAME.getWorld()[index];
                            if (data > 0) {
                                data -= 1;
                                var x = renderer.column;
                                var y = renderer.row;
                                let entity = GAME.getEntity(data);
                                let element_entity = document.querySelector('div[data-entity="' + data + '"]');
                                if (!element_entity)
                                {
                                    element_entity = document.createElement('div');
                                    element_entity.setAttribute('data-entity', data.toString());
                                    element_entity.classList.add('thing');
                                    element_view.append(element_entity);
                                    if (data === 0)
                                    {
                                        element_entity.classList.add('purple');
                                    }
                                    else
                                    {
                                        element_entity.classList.add('red');
                                    }
                                }
                                element_entity.setAttribute('data-x', x);
                                element_entity.setAttribute('data-y', y);
                                element_entity.style.left = (x * (SIZE * SCALE)) + 'px';
                                element_entity.style.top = (y * (SIZE * SCALE)) + 'px';
                                element_entity.innerHTML = entity.health;
                            }
                        }

                        ++renderer.column;
                        if (renderer.column >= DOM.width) {
                            renderer.column = 0;
                            ++renderer.row;
                        }
                    }

                    EDITOR.camera_has_changed = false;
                },
                initGame: function ()
                {
                    // TODO: Hide game or do not show it until you're done all this stuff first. Loading bar?
                    this.sizeView();
                    GAME.setViewportSize(DOM.width, DOM.height);
                    GAME.updateViewportData();

                    this.renderWorld();
                },
                sizeView: function ()
                {
                    // Full height, including the scroll part
                    const full_height = Math.max(
                        // document.body.scrollHeight,
                        // document.documentElement.scrollHeight,
                        // document.body.offsetHeight,
                        // document.documentElement.offsetHeight,
                        document.body.clientHeight,
                        // document.documentElement.clientHeight
                    );
                    // Full width, including the scroll part
                    const full_width = Math.max(
                        // document.body.scrollWidth,
                        // document.documentElement.scrollWidth,
                        // document.body.offsetWidth,
                        // document.documentElement.offsetWidth,
                        document.body.clientWidth,
                        // document.documentElement.clientWidth
                    );

                    const root = document.documentElement;
                    root.style.setProperty('--scale', SCALE);

                    console.log({full_width, full_height});

                    let x = Math.floor(full_width / (SIZE * SCALE));
                    let y = Math.floor(full_height / (SIZE * SCALE));
                    // So we add a bit more space in the view
                    if (x > 6)
                    {
                        --x;
                    }
                    if (y > 6)
                    {
                        --y;
                    }
                    let x_padding = (full_width - (x * (SIZE * SCALE))) / 2;
                    let y_padding = (full_height - (y * (SIZE * SCALE))) / 2;
                    document.getElementById('view').style.margin = y_padding + 'px ' + x_padding + 'px';
                    document.getElementById('view').style.width = (x * (SIZE * SCALE)) + 'px';
                    document.getElementById('view').style.height = (y * (SIZE * SCALE)) + 'px';
                    document.getElementById('clickable_view').style.width = (x * (SIZE * SCALE)) + 'px';
                    document.getElementById('clickable_view').style.height = (y * (SIZE * SCALE)) + 'px';
                    DOM.width = x;
                    DOM.height = y;
                }
            };

            const resizeObserver = new ResizeObserver((entries) => {
                const entry = entries[0];
                // entry.contentRect
                // REDO sizing and grid
                console.log('resize called');
                //DOM.sizeView();
                // TODO: Clean this up later. initGame not a good function for this
                if (GAME) {
                    DOM.initGame();
                }
            });

            let then = performance.now();
            const interval = 1000 / 30;
            let delta = 0;
            function animateEntities () {
                let now = performance.now();
                if (now - then >= interval - delta) {
                    delta = Math.min(interval, delta + now - then - interval);
                    then = now;

                    if (_testScript[_testScript_i]) {
                        _testScript[_testScript_i]();
                    }
                    DOM.renderWorld();
                    if (GAME.getDiffListLen() > 0) {
                        let diff_list = GAME.getDiffList();
                        var mode = null;
                        var values_read = 0;
                        const MODES = ['entity', 'world', 'collision'];
                        var collision_update = [null, null, null];
                        for (var d = 0; d < diff_list.length; ++d) {
                            // TODO: You need to merge this with the general renderer so that the general renderer only happens when you render the WHOLE world and the diff list happens when you only want to re-render *portions* of the world
                            // Update diff_list so you only update the part of the viewport that needs updating (could be all or a specific coordinate or specific coordinates) of the viewport_data from GAME.getViewportData()
                            if (mode === null) {
                                mode = MODES[diff_list[d]];
                                if (mode === 'collision') {
                                    console.log(diff_list.slice(d, d+8));
                                }
                            } else {
                                if (mode === 'entity') {
                                    let element_entity = document.querySelector('div[data-entity="' + diff_list[d] + '"]');
                                    if (element_entity) {
                                        element_entity.remove();
                                        ++values_read;
                                        if (values_read == 1) {
                                            mode = null;
                                        }
                                    } else {
                                        console.error('COULD NOT FIND ENTITY: ' + diff_list[d]);
                                    }
                                } else if (mode === 'world') {
                                    // TODO: This... is what?
                                } else if (mode === 'collision') {
                                    if (collision_update[0] === null) {
                                        collision_update[0] = diff_list[d];
                                    } else if (collision_update[1] === null) {
                                        collision_update[1] = diff_list[d];
                                    } else if (collision_update[2] === null) {
                                        collision_update[2] = diff_list[d];
                                    }
                                    ++values_read;
                                    if (values_read === collision_update.length) {
                                        if (collision_update[0] === 1) {
                                            let collision_element = document.querySelector('div[data-x="' + collision_update[1] + '"][data-y="' + collision_update[2] + '"]');
                                            collision_element.remove();
                                            mode = null;
                                        } else {
                                            console.log('Collision Update:', collision_update);
                                            let element_world = document.getElementById('world');
                                            let element_item = document.querySelector('div[data-x="' + collision_update[1] + '"][data-y="' + collision_update[2] + '"]');
                                            if (!element_item)
                                            {
                                                element_item = document.createElement('div');
                                                element_item.setAttribute('data-x', collision_update[1]);
                                                element_item.setAttribute('data-y', collision_update[2]);
                                                element_item.classList.add('thing');
                                            }
                                            element_item.style.left = (collision_update[1] * (SIZE * SCALE)) + 'px';
                                            element_item.style.top = (collision_update[2] * (SIZE * SCALE)) + 'px';
                                            element_item.classList.add('blue');
                                        }
                                    }
                                }
                            }
                        }
                        console.log('diff_list', diff_list);
                        // for (let i = 0; i < diff_list.length; ++i) {
                        //     let position = GAME.getEntityPosition(diff_list[i]);
                        // }
                        GAME.clearDiffList();
                    }
                }
            };
            function animate() {
                // call this function again asap
                requestAnimationFrame(animate);
                // measure time and add or remove sprites
                STATS.checkFPS();
                
                // deal with the level
                animateEntities();
            }

            LOADER.events.addEventListener('loaded', function (a) {
                // console.log(a);
                // run each frame
                GAME.initGame();
                DOM.initGame();
                animate();
            });
            window.addEventListener('load', function () {
                var element_view = document.getElementById('view');
                var element_clickable_view = document.getElementById('clickable_view');
                element_clickable_view.addEventListener('click', function (e) {
                    let x = Math.floor(e.offsetX / (SIZE * SCALE));
                    let y = Math.floor(e.offsetY / (SIZE * SCALE));
                    console.log('click', x, y);
                    EDITOR.last_clicked_coordinates = [x, y];
                    // TODO: if you move the camera around after you clicked, you need to re-click or update coordinates
                    var clicked_element = document.querySelector('div.thing[data-x="' + x + '"][data-y="' + y + '"]');
                    console.log(clicked_element);
                    if (clicked_element) {
                        if (clicked_element.classList.contains('thing')) {
                            if (clicked_element.classList.contains('blue')) {
                                clicked_element.classList.add('chosen');
                            }
                        }
                    }
                });
                resizeObserver.observe(document.body);
                LOADER.loaded('window_ready');
            });
        </script>
        <style type="text/css">
            :root {
                --scale: 1;
                --size: 32;
                --scaled-size: calc(var(--size) * var(--scale));
                --scaled-size-px: calc(var(--scaled-size) * 1px);
            }
            * {
                box-sizing: border-box;
            }
            body {
                margin: 0px;
                padding: 0px;
                overflow: hidden;

                background-color: black;
            }
            #clickable_view {
                width: 100%;
                height: 100vh;
                position: absolute;
                z-index: 1000;
            }
            #view {
                width: 100%;
                height: 100vh;
                /*display: flex;
                align-items: center;
                justify-content: center;*/
                background-image: 
                    linear-gradient(rgba(0, 255, 0, .7) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0, 255, 0, .7) 1px, transparent 1px);
                background-size: var(--scaled-size-px) var(--scaled-size-px);
                background-position: -1px -1px;
                border: 1px solid red;

                position: relative;
            }
            .thing {
                transform: scale3d(1, 1, 1);
                position: absolute;
                width: var(--scaled-size-px);
                height: var(--scaled-size-px);
                color: white;
                font-weight: bold;
            }
            #grid {
                display: grid;
                margin: 0px auto;
                align-self: center;
                justify-self: center;
            }
            .purple { background: url('data:image/webp;base64,UklGRjADAABXRUJQVlA4TCQDAAAvf8AXAGdgJJKUl1/jI5AeeUEIgEUSxUgAJFRmcIWdbiEaNdrcYiQAEq7ABDZyg31Go8b5j/ktFKFTkLc3vs2kMngigN5DCSTVtl03kiiIgig8CqIgCnfcM1EwhUfBDHo9CkGl91NZ9jyi/xDctpEkKT0zm8VWjfos7xfkvkXEjWOWz3m4cVaFRb7owRyYyN88sOX1CjLB+973AGHT6zha8cmQLQ/PptdxEgdm3vcYhE2v8zw3lbJ34b0CCU5Q5oHIQ/spd+75GqL5mK2HUw08DMYr93wBLHfsw87DoAaQ2zhc03rlnufR4fkDwPVao0BYadN65Z4vgDl5EKiH5/f7DQKbvk02XrnneZJbwSuBVdUhpl+N8co9jxN87X871p8sA4CF7d2fhNdL6nGOUIf1VNmDpapgFkdbLC9OPfk0+UqxfgLgaA32S00fNNnT5QXEOQCr9HkF5VKYQzZzxHk2c8EgoC3YNPoy7OWK02wvE5YCSdhaZh7mwdxhKcqtCtQMuznjPFs5YZiDZRBPadfczBmP8lzuCFgeAeWaAJDnjPNsXQiDFnVx+YmolWIeKZ2QXniHyXNAyLW2BnMIK2or+P0sce44wwO5YxACOKBAa5HmjhewkRsiCswhbAULnepe5J7nkWQNMv21KGtLaVNWk+eO8+Q5IGYQlIrmtkXu+Tx/zR2mLwYKaARDaZ2Qespp8hygFAVYrVuzL3Jt6YQsd5wnzwGmxzB6HhFCH6YWOhOC3HGeIAeEPcRCgHiFjjGIaEGrRvD0eAFxDnCWFYu+qvberQLBHC/dTCHIHefJcoD5XwEVtsjkRmfgflB6RZA7zpMsA/56qURESlpjVNh3t+wcJS+AVz8qkWkIaZEpC8LccR63/KCGppWiqrWUQhRaXRfC3HGQZAioh4Xer+tqSLuGdrVLX1HuOI+fCmGtDTqUkHbdjsOcQe54AVs5wPwGQKetDmXO6XLHazACc6uoa9dpzqAr2oW54wWEOUByelmdm+mfkygzyx3PMbf5Y47oRTvuRXy3kTPOk+eI73nkOeJrHnlu+J5Hnhs+4/GH3PFBDwE=');
                background-size: contain;
                background-repeat: no-repeat;
            }
            .red { background-color:red; }
            .blue { background-color: blue; }
            .chosen {
                border: 1px solid pink;
            }
            .editor_block {
                position: absolute;
                background-color: rgb(255 255 255 / 10%);
                width: var(--scaled-size-px);
                height: var(--scaled-size-px);
                z-index: 101;

                font-size: 12px;
                color: white;
                font-weight: bold;
                font-family: monospace;
            }
            .editor_block .data {
                position: absolute;
                top: 0px;
                left: 0px;
                font-size: 16px;
                display: none;
            }
            .editor_block .data.has_value {
                display: block;
            }
            .editor_block .coordinate {
                position: absolute;
                bottom: 0px;
                left: 0px;
            }
        </style>
    </head>
    <body>
        <div class="editor" id="editor_menu" style="display: none; position: absolute; background-color: gray; color: white; padding: 6px; z-index: 101; top: 0px; width: 100%; font-family: monospace;">
            <div style="width: 100%; display: grid; grid-template-columns: repeat(4, max-content); grid-gap: 10px;">
                <div onclick="EDITOR.getWorld(); EDITOR.worldDataToZig(EDITOR.worlds_list[0]);">File</div>
                <div>
                    <div id="edit">Edit</div>
                    <div id="edit_submenu">
                        <div onclick="console.log('atest'); EDITOR.override_data_mode = true;">Save</div>
                        <div onclick="EDITOR.generateEntityArray(20, 1, 12);">Close</div>
                        <div onclick="EDITOR.generateWorldArray(5, 5);">Generate New World</div>
                    </div>
                </div>
                <div id="stats" style="background-color: white; color: black; padding: 6px;">&nbsp;</div>
                <div id="current_layer" style="background-color: orange; padding: 6px;">Current Layer: <span class="layer_number">0</span></div>
            </div>

            <div style="background-color: pink; color: white; font-weight: bold;">
                <input type="text" name="health" value="10" />
                <input type="text" name="position_x" value="1" />
                <input type="text" name="position_y" value="12" />
            </div>
        </div>
        <div id="view">
            <div id="clickable_view"></div>
            <style type="text/css">
                .menu.date {
                    width: 100%;
                    height: calc(var(--scaled-size-px) * 2);
                    position: absolute;
                    top: 0;
                    left: 0;
                    text-align: right;
                    font-size: 2em;
                    color: white;
                    text-shadow: 0 0 2px black, 0 0 2px black, 0 0 2px black;
                    font-family: monospace;
                }
            </style>
            <div class="menu date">
                <div class="year">1527</div>
                <div class="month_and_day"><span class="month">May</span> <span class="day">22</span></div>
            </div>
            <style type="text/css">
                .menu.fullscreen {
                    background-color: rgb(82 159 82 / 90%);
                    width: 100%;
                    height: 100%;
                    position: absolute;
                    z-index: 99;
                    bottom: 0;
                    left: 0;
                    display: none;
                    text-align: center;
                    font-weight: bold;
                    font-size: 2em;
                    color: white;
                }
            </style>
            <div class="menu fullscreen">
                FULL SCREEN
            </div>
        </div>
    </body>
</html>
